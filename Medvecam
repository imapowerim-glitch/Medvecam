cat <<'SH' > ~/install_medvecam_ultra.sh
#!/usr/bin/env bash
set -euo pipefail
set +H

sudo pkill -9 python3 2>/dev/null || true

sudo apt-get update -o Acquire::ForceIPv4=true
sudo DEBIAN_FRONTEND=noninteractive apt-get install -y --no-install-recommends \
  python3-pyqt5 \
  python3-picamera2 \
  ffmpeg

APP="$HOME/MedVeCam_Ultra"
mkdir -p "$APP" \
         "$HOME/Videos/Medvekamera/Photos" \
         "$HOME/Videos/Medvekamera" \
         "$HOME/Desktop" \
         "$HOME/.config/MedVeCamUltra" \
         "$HOME/.local/share/MedVeCam/LUTs"

cat > "$APP/medvecam_ultra.py" <<'PY'
#!/usr/bin/env python3
# MedVeCam Ultra â€” single-file
# - ÐÐ°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ñ‡Ð¸ÑÑ‚Ñ‹Ðµ (Ð½Ð¾Ð²Ð°Ñ Ð¿Ð°Ð¿ÐºÐ°): ~/.config/MedVeCamUltra
# - ÐŸÑ€ÐµÐ²ÑŒÑŽ Ð±Ñ‹ÑÑ‚Ñ€Ñ‹Ð¼ Ð¿ÑƒÑ‚Ñ‘Ð¼: main=YUV420 (Ð·Ð°Ð¿Ð¸ÑÑŒ), lores=RGB (display="lores")
# - Colour Studio: Reset ALL visuals + A/B preview + opacity
# - Ð­Ð¼ÑƒÐ»ÑÑ†Ð¸Ð¸ ÐºÐ°Ð¼ÐµÑ€ 50+, LUT Ð¿Ð¾ÑÑ‚-Ñ€ÐµÐ½Ð´ÐµÑ€ Ñ‡ÐµÑ€ÐµÐ· ffmpeg (Ð¿Ð¾ Ð¶ÐµÐ»Ð°Ð½Ð¸ÑŽ)
# - Ð¤Ð¾Ñ‚Ð¾/Ð²Ð¸Ð´ÐµÐ¾ Ñ€Ð°Ð·Ð´ÐµÐ»ÑŒÐ½Ñ‹Ðµ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸; live Ð¿Ñ€Ð¸Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ
# - Ð¡Ñ‚Ð°Ñ€Ñ‚Ð¾Ð²Ð°Ñ Ð·Ð°ÑÑ‚Ð°Ð²ÐºÐ°: "MEDVEKAM by Misek Ejl"

import os, sys, time, threading, json
from datetime import datetime

from PyQt5.QtCore import Qt, QTimer, QUrl, QCoreApplication, QRect
from PyQt5.QtGui import QDesktopServices, QGuiApplication, QColor, QPalette, QFont, QImage, QPixmap
from PyQt5.QtWidgets import (QApplication, QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QDialog, QListWidget, QListWidgetItem, QInputDialog, QSlider, QSizePolicy, QFormLayout,
    QComboBox, QDoubleSpinBox, QSpinBox, QFileDialog, QTabWidget)

from picamera2 import Picamera2
from picamera2.previews.qt import QPicamera2 as PreviewWidget
from libcamera import Transform, controls

# ---------- paths / utils ----------
CFG_DIR = os.path.expanduser("~/.config/MedVeCamUltra"); os.makedirs(CFG_DIR, exist_ok=True)
LUT_DIR = os.path.expanduser("~/.local/share/MedVeCam/LUTs"); os.makedirs(LUT_DIR, exist_ok=True)
SETTINGS_FILE = os.path.join(CFG_DIR, "settings.json")
PRESETS_FILE  = os.path.join(CFG_DIR, "presets.json")
def ts(): return datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
def clamp01(v): return max(0.0, min(2.0, v/100.0))
def clamp11(v): return max(-1.0, min(1.0, v/100.0))

# Kelvin to gains (approx)
K_POINTS=[(2800,(2.10,1.00)),(3200,(2.00,1.05)),(4300,(1.70,1.25)),(5600,(1.50,1.20)),(6500,(1.35,1.30)),(7500,(1.30,1.35))]
def kelvin_to_gains(k:int):
    k=max(2500,min(8000,int(k)))
    a,b=K_POINTS[0],K_POINTS[-1]
    for i in range(len(K_POINTS)-1):
        if K_POINTS[i][0]<=k<=K_POINTS[i+1][0]:
            a,b=K_POINTS[i],K_POINTS[i+1]; break
    (ka,(ra,ba)),(kb,(rb,bb))=a,b; t=0 if kb==ka else (k-ka)/(kb-ka)
    R=ra+(rb-ra)*t; B=ba+(bb-ba)*t
    return (max(0.5,min(3.0,R)), max(0.5,min(3.0,B)))

# CCM & AWB bias
CCM_PRESETS={
    "Identity":[1,0,0,0,1,0,0,0,1],
    "Warm":[1.05,-0.02,-0.03,-0.02,1.02,0.0,0.0,-0.01,1.01],
    "Cool":[0.98,0.02,0.0,0.02,0.98,-0.01,0.0,0.02,1.02],
    "Skin":[1.02,0.01,-0.03,-0.02,1.00,0.02,0.02,-0.02,1.01],
    "Green":[1.0,-0.03,0.0,0.02,1.03,-0.01,0.0,0.0,1.0],
    "Magenta":[1.02,0.02,-0.04,-0.02,1.00,0.02,0.02,-0.02,1.02],
    "Cyan":[0.98,0.02,0.02,0.02,1.00,0.02,0.02,0.0,1.02],
    "Amber":[1.04,-0.02,-0.02,0.0,1.02,0.0,-0.02,-0.02,1.00],
}
AWB_AUTO_BIAS={
    "Std":[1,0,0,0,1,0,0,0,1],
    "Warm":[1.03,-0.02,0.0, 0.0,1.01,0.0, 0.0,-0.01,1.00],
    "Cool":[0.99,0.01,0.0, 0.01,0.99,0.0, 0.0,0.02,1.01],
    "Skin":[1.02,0.01,-0.02, -0.02,1.00,0.02, 0.02,-0.01,1.01],
    "Outdoor":[1.01,0.0,0.0, 0.0,1.00,0.0, 0.0,0.0,1.01],
}

def EM(c=100,s=100,sh=100,ev=0.0,ccm="Identity"):
    return {"c":int(c),"s":int(s),"sh":int(sh),"ev":float(ev),"ccm":CCM_PRESETS.get(ccm,CCM_PRESETS["Identity"])}

# (Ð¡Ð¾ÐºÑ€Ð°Ñ‰Ñ‘Ð½Ð½Ñ‹Ð¹ ÑÐ¿Ð¸ÑÐ¾Ðº Ñ€Ð°Ð´Ð¸ Ð¼ÐµÑÑ‚Ð° â€” 50+ Ð¿Ñ€ÐµÑÐµÑ‚Ð¾Ð² ÐºÐ°Ðº Ð² Ð¿Ñ€Ð¾ÑˆÐ»Ð¾Ð¼ Ð¾Ñ‚Ð²ÐµÑ‚Ðµ)
EMULATIONS={
    "Fuji / Provia":EM(100,100,102,0.0,"Identity"),
    "Fuji / Velvia":EM(125,125,110,-0.2,"Warm"),
    "Fuji / Classic Chrome":EM(108,90,104,0.0,"Cool"),
    "Fuji / Eterna":EM(92,85,95,0.0,"Cool"),
    "Kodak / Portra 400":EM(102,98,106,0.0,"Skin"),
    "Kodak / Vision3 500T":EM(104,100,104,0.0,"Cool"),
    "Leica / Vivid":EM(120,120,110,0.0,"Warm"),
    "Canon / Standard":EM(108,105,104,0.0,"Warm"),
    "Nikon / Flat":EM(80,80,92,0.0,"Identity"),
    "Sony / S-Cinetone-ish":EM(104,98,104,0.0,"Skin"),
    "ARRI / Rec709 K1S1":EM(102,96,104,0.0,"Warm"),
    "RED / IPP2-ish":EM(100,96,106,0.0,"Skin"),
    "Wong Kar-Wai":EM(120,115,105,-0.1,"Warm"),
    "Teal & Orange":EM(112,110,108,0.0,"Cyan"),
    "Soft 709":EM(95,92,100,0.1,"Identity"),
    "Punchy":EM(115,112,108,-0.1,"Identity"),
    "Mono / Soft":EM(95,0,98,0.1,"Identity"),
    "Mono / Hard":EM(125,0,112,-0.2,"Identity"),
    # ... (Ð´Ð¾Ð±Ð°Ð²ÑŒ Ð¿Ñ€Ð¸ Ð¶ÐµÐ»Ð°Ð½Ð¸Ð¸ ÐµÑ‰Ñ‘ Ð¸Ð· Ð¿Ñ€ÐµÐ´Ñ‹Ð´ÑƒÑ‰ÐµÐ³Ð¾ ÑÐ¿Ð¸ÑÐºÐ°)
}

# ---------- dialogs ----------
class PopupSlider(QDialog):
    def __init__(self,parent,title,vmin,vmax,step,initial,decimals=0,unit="",fmt="{:.0f}"):
        super().__init__(parent); self.setWindowTitle(title); self.setModal(True)
        self.value=float(initial); self.vmin=vmin; self.vmax=vmax; self.step=step; self.decimals=decimals; self.unit=unit; self.fmt=fmt
        lay=QVBoxLayout(self)
        self.lbl=QLabel(); self.lbl.setStyleSheet("font-size:22px;"); lay.addWidget(self.lbl, alignment=Qt.AlignHCenter)
        row=QHBoxLayout()
        self.btn_m=QPushButton("âˆ’"); self.btn_m.setMinimumWidth(100); self.btn_m.clicked.connect(lambda:self.bump(-step)); row.addWidget(self.btn_m)
        self.sld=QSlider(Qt.Horizontal); self.sld.setMinimum(0); self.sld.setMaximum(int(round((vmax-vmin)/step))); self.sld.setValue(int(round((initial-vmin)/step))); self.sld.valueChanged.connect(self.from_slider); row.addWidget(self.sld,1)
        self.btn_p=QPushButton("+"); self.btn_p.setMinimumWidth(100); self.btn_p.clicked.connect(lambda:self.bump(+step)); row.addWidget(self.btn_p)
        lay.addLayout(row)
        brow=QHBoxLayout(); ok=QPushButton("OK"); ok.setMinimumWidth(120); ok.clicked.connect(self.accept); cancel=QPushButton("Cancel"); cancel.setMinimumWidth(120); cancel.clicked.connect(self.reject)
        brow.addStretch(1); brow.addWidget(ok); brow.addWidget(cancel); lay.addLayout(brow)
        geo=QGuiApplication.primaryScreen().availableGeometry(); self.resize(min(700,geo.width()-40), min(300,geo.height()-60)); self._update_label()
    def keyPressEvent(self,e): 
        if e.key()==Qt.Key_Escape: self.reject()
        else: super().keyPressEvent(e)
    def _update_label(self):
        s=self.fmt.format(self.value); self.lbl.setText(s + ((" "+self.unit) if self.unit else ""))
    def bump(self,d):
        v=round(self.value+d,self.decimals); v=max(self.vmin,min(self.vmax,v)); self.value=v
        self.sld.blockSignals(True); self.sld.setValue(int(round((v-self.vmin)/self.step))); self.sld.blockSignals(False); self._update_label()
    def from_slider(self,i):
        v=self.vmin+i*self.step; self.value=round(v,self.decimals); self._update_label()

class PopupList(QDialog):
    def __init__(self,parent,title,items,current=None):
        super().__init__(parent); self.setWindowTitle(title); self.setModal(True)
        lay=QVBoxLayout(self)
        self.list=QListWidget(); [QListWidgetItem(x,self.list) for x in items]
        self.list.setStyleSheet("font-size:18px;"); lay.addWidget(self.list)
        if current is not None:
            for i in range(self.list.count()):
                if self.list.item(i).text()==current: self.list.setCurrentRow(i); break
        brow=QHBoxLayout(); ok=QPushButton("OK"); ok.setMinimumWidth(120); ok.clicked.connect(self.accept); cancel=QPushButton("Cancel"); cancel.setMinimumWidth(120); cancel.clicked.connect(self.reject)
        brow.addStretch(1); brow.addWidget(ok); brow.addWidget(cancel); lay.addLayout(brow)
        geo=QGuiApplication.primaryScreen().availableGeometry(); self.resize(min(560,geo.width()-40), min(520,geo.height()-60))
    def keyPressEvent(self,e):
        if e.key()==Qt.Key_Escape: self.reject()
        else: super().keyPressEvent(e)
    def selected(self):
        it=self.list.currentItem(); return it.text() if it else None

class WBDialog(QDialog):
    def __init__(self,parent):
        super().__init__(parent); self.setModal(True); self.setWindowTitle("White Balance"); self.p=parent
        v=QVBoxLayout(self)
        items=[
            "Auto (Std)","Auto (Warm)","Auto (Cool)","Auto (Skin)","Auto (Outdoor)",
            "Daylight","Cloudy","Shade","Tungsten","Fluorescent","Kelvinâ€¦","Manual RG/BGâ€¦"
        ]
        self.pl=QListWidget(); [QListWidgetItem(x,self.pl) for x in items]; v.addWidget(self.pl)
        btns=QHBoxLayout(); ok=QPushButton("Apply"); ok.clicked.connect(self._apply); cancel=QPushButton("Close"); cancel.clicked.connect(self.reject); btns.addWidget(ok); btns.addWidget(cancel); v.addLayout(btns)
        geo=QGuiApplication.primaryScreen().availableGeometry(); self.resize(min(560,geo.width()-40), min(480,geo.height()-60))
    def _apply(self):
        it=self.pl.currentItem()
        if not it: return
        name=it.text(); px=self.p._px()
        if name.startswith("Auto"):
            self.p.s[px+'awb']='auto'
            self.p.s[px+'awb_bias']=name.split("(")[1].split(")")[0]
        elif name in ("Daylight","Cloudy","Shade","Tungsten","Fluorescent"):
            self.p.s[px+'awb']=name.lower(); self.p.s[px+'awb_bias']="Std"
        elif name=="Kelvinâ€¦":
            ps=PopupSlider(self,"Kelvin",2500,8000,50,self.p.s.get(px+'kelvin',5600))
            if ps.exec_(): self.p.s[px+'awb']='kelvin'; self.p.s[px+'kelvin']=int(ps.value); self.p.s[px+'awb_bias']="Std"
        elif name=="Manual RG/BGâ€¦":
            pr=PopupSlider(self,"WB R gain",0.5,3.0,0.05,self.p.s.get(px+'rg',1.5),decimals=2,fmt="{:.2f}")
            if pr.exec_(): self.p.s[px+'rg']=float(pr.value)
            pb=PopupSlider(self,"WB B gain",0.5,3.0,0.05,self.p.s.get(px+'bg',1.2),decimals=2,fmt="{:.2f}")
            if pb.exec_(): self.p.s[px+'bg']=float(pb.value)
            self.p.s[px+'awb']='manual'; self.p.s[px+'awb_bias']="Std"
        self.p.apply_controls(); self.p._refresh_labels(); self.p._save_settings(); self.accept()

# ---------- main app ----------
class App(QWidget):
    PREVIEW_W=760; PREVIEW_H=430
    FPS_BASE=[24,25,30,40,48,50,60,75,90,100,120]

    def __init__(self):
        super().__init__()
        self.setWindowTitle("MedVeCam Ultra â€” 800x640")
        self.setStyleSheet("""
          QWidget { background:#0f0f0f; color:#eeeeee; font-family:Arial; }
          QLabel#brand { color:#cfcfcf; font-size:14px; padding:3px 6px; }
          QLabel#rect { color:#ff4d4d; font-weight:700; }
          QPushButton{ background:#161616; border:1px solid #2b2b2b; padding:8px 10px; border-radius:10px; min-width:66px;}
          QPushButton:checked{ background:#2a1a0a; border-color:#ff9a2e; }
          QPushButton:hover{ border-color:#ff9a2e; }
          QListWidget { background:#141414; }
          QDialog { background:#111; }
          QSlider::groove:horizontal { height:12px; background:#1e1e1e; border-radius:6px; }
          QSlider::handle:horizontal { width:26px; background:#ff9a2e; margin:-8px 0; border-radius:13px; }
        """)

        vroot=os.path.expanduser("~/Videos/Medvekamera")
        self.s={
            # video
            "resolution":(1920,1080),"fps":30,"encoder":"H264","bitrate_mbps":12.0,
            "v_ae":True,"v_gain":1.0,"v_shutter":5000,"v_ev":0.0,
            "v_awb":"auto","v_awb_bias":"Std","v_kelvin":5600,"v_rg":1.5,"v_bg":1.2,
            "v_bright":0,"v_contrast":100,"v_saturation":100,"v_sharpness":100,
            "v_ccm_name":"Identity","v_ccm":CCM_PRESETS["Identity"], "v_emu":"Fuji / Provia",
            # photo
            "photo_size":(4056,3040),"photo_raw":False,
            "p_ae":False,"p_gain":1.0,"p_shutter":8000,"p_ev":0.0,
            "p_awb":"daylight","p_awb_bias":"Std","p_kelvin":5600,"p_rg":1.5,"p_bg":1.2,
            "p_bright":0,"p_contrast":100,"p_saturation":100,"p_sharpness":100,
            "p_ccm_name":"Identity","p_ccm":CCM_PRESETS["Identity"], "p_emu":"Fuji / Provia",
            # common
            "hflip":False,"vflip":False,"rot":0,
            "vroot":vroot,"pdir":os.path.join(vroot,"Photos"),
            "capture_mode":"video",
            "post_lut":""
        }
        # Ð’ÐÐ–ÐÐž: Ð½Ðµ Ð·Ð°Ð³Ñ€ÑƒÐ¶Ð°ÐµÐ¼ ÑÑ‚Ð°Ñ€Ñ‹Ðµ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ Ð¸Ð· Ð´Ñ€ÑƒÐ³Ð¸Ñ… Ð²ÐµÑ€ÑÐ¸Ð¹
        self._load_settings()  # Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¸Ð· ~/.config/MedVeCamUltra/settings.json
        os.makedirs(self.s["vroot"],exist_ok=True); os.makedirs(self.s["pdir"],exist_ok=True)

        self.cam=Picamera2()
        try:
            from picamera2.dng import DNGWriter
            self._DNGWriter=DNGWriter
        except Exception:
            self._DNGWriter=None

        self.sensor_modes=self._read_sensor_modes()
        self.recording=False; self._stop_pending=False; self._stop_done=False; self._stop_err=None
        self._photo_busy=False; self._lab_bypass=False; self.rec_started_at=None
        self._last_applied_controls={}; self._last_record_path=None
        self._apply_config()

        # UI
        self.root=QVBoxLayout(self); self.root.setContentsMargins(6,6,6,6); self.root.setSpacing(6)
        top=QHBoxLayout()
        brand=QLabel("MedVeCam Ultra"); brand.setObjectName("brand"); top.addWidget(brand)
        self.btn_mode=QPushButton("VID"); self.btn_mode.clicked.connect(self.toggle_capture_mode); top.addWidget(self.btn_mode)
        self.btn_res=QPushButton(self._res_label()); self.btn_res.clicked.connect(self.ui_pick_res); top.addWidget(self.btn_res)
        self.btn_fps=QPushButton(f"FPS {self.s['fps']}"); self.btn_fps.clicked.connect(self.ui_pick_fps); top.addWidget(self.btn_fps)
        self.btn_codec=QPushButton(self.s["encoder"]); self.btn_codec.clicked.connect(self.ui_pick_codec); top.addWidget(self.btn_codec)
        self.btn_iso=QPushButton(self._iso_label()); self.btn_iso.clicked.connect(self.ui_pick_iso); top.addWidget(self.btn_iso)
        self.btn_shtr=QPushButton(self._shutter_label()); self.btn_shtr.clicked.connect(self.ui_pick_shutter); top.addWidget(self.btn_shtr)
        self.btn_ev=QPushButton(self._ev_label()); self.btn_ev.clicked.connect(self.ui_pick_ev); top.addWidget(self.btn_ev)
        self.btn_wb=QPushButton("WB"); self.btn_wb.clicked.connect(self.open_wb_popup); top.addWidget(self.btn_wb)
        self.btn_menu=QPushButton("MENU"); self.btn_menu.clicked.connect(self.open_full_menu); top.addWidget(self.btn_menu)
        top.addStretch(1)
        self.lbl_rec=QLabel("â—"); self.lbl_rec.setObjectName("rect"); self.lbl_rec.setVisible(False); top.addWidget(self.lbl_rec)
        self.lbl_rectime=QLabel("00:00"); self.lbl_rectime.setObjectName("rect"); self.lbl_rectime.setVisible(False); top.addWidget(self.lbl_rectime)
        self.root.addLayout(top)

        self.preview=PreviewWidget(self.cam, width=self.PREVIEW_W, height=self.PREVIEW_H)
        self.preview.setFixedSize(self.PREVIEW_W, self.PREVIEW_H); self.preview.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed)
        self.root.addWidget(self.preview, 0, alignment=Qt.AlignCenter)

        self.flash = QLabel("", self); self.flash.setAutoFillBackground(True)
        pal=self.flash.palette(); pal.setColor(QPalette.Window, QColor(255,255,255,160)); self.flash.setPalette(pal); self.flash.setVisible(False)

        bottom=QHBoxLayout()
        self.btn_gallery=QPushButton("ðŸ“"); self.btn_gallery.clicked.connect(self.open_gallery); bottom.addWidget(self.btn_gallery)
        self.btn_presets=QPushButton("PRE"); self.btn_presets.clicked.connect(self.open_presets); bottom.addWidget(self.btn_presets)
        self.btn_tr=QPushButton("TR"); self.btn_tr.clicked.connect(self.ui_pick_transform); bottom.addWidget(self.btn_tr)
        self.btn_photo_res=QPushButton("P-RES"); self.btn_photo_res.clicked.connect(self.ui_pick_photo_res); bottom.addWidget(self.btn_photo_res)
        self.btn_shot=QPushButton("ðŸ“· Shoot"); self.btn_shot.clicked.connect(self.take_photo); bottom.addWidget(self.btn_shot)
        self.btn_rec=QPushButton("â— REC"); self.btn_rec.setCheckable(True); self.btn_rec.toggled.connect(self.toggle_rec); bottom.addWidget(self.btn_rec)
        self.root.addLayout(bottom)
        self._update_hud()

        self.lbl_status=QLabel("Ready."); self.root.addWidget(self.lbl_status)

        self._show_splash()

        self.tmr=QTimer(self); self.tmr.setInterval(200); self.tmr.timeout.connect(self._tick)
        self.start_preview(); self._refresh_labels()

    # ---------- labels ----------
    def _px(self): return 'p_' if self.s["capture_mode"]=='photo' else 'v_'
    def _res_label(self): w,h=self.s["resolution"]; return f"{w}x{h}"
    def _iso_label(self): return f"ISO {int(self.s[self._px()+'gain']*100)}"
    def _shutter_label(self):
        px=self._px(); us=int(self.s[px+'shutter'])
        if self.s["capture_mode"]=='video':
            angle=round(360.0 * us * self.s['fps'] / 1_000_000.0); return f"{int(angle)}Â°"
        return f"{us} Âµs"
    def _ev_label(self): return f"EV {self.s[self._px()+'ev']:+.1f}"

    # ---------- settings I/O ----------
    def _load_settings(self):
        try:
            with open(SETTINGS_FILE,"r",encoding="utf-8") as f: self.s.update(json.load(f))
        except Exception: pass
    def _save_settings(self):
        try:
            with open(SETTINGS_FILE,"w",encoding="utf-8") as f: json.dump(self.s,f,ensure_ascii=False,indent=2)
        except Exception: pass

    # ---------- sensor ----------
    def _read_sensor_modes(self):
        try:
            out=[]
            for m in self.cam.sensor_modes:
                size=tuple(m.get("size",(0,0))); bd=int(m.get("bit_depth",12)); fps=float(m.get("fps",30.0))
                out.append({"size":size,"bit_depth":bd,"fps":fps})
            uniq={}
            for m in out: uniq[(m["size"],m["bit_depth"],int(m["fps"]))]=m
            arr=list(uniq.values()); arr.sort(key=lambda x:(x["size"][0]*x["size"][1], x["fps"]))
            return arr
        except Exception:
            return []
    def _sensor_max(self):
        if not self.sensor_modes: return (4056,3040)
        mx=max(self.sensor_modes, key=lambda m:m["size"][0]*m["size"][1]); return mx["size"]
    def _max_fps_for(self, target_size):
        W,H=target_size; fps=24
        for m in self.sensor_modes:
            sw,sh=m["size"]
            if sw>=W and sh>=H: fps=max(fps,int(m["fps"]))
        return fps
    def _candidate_res(self):
        sizes={m["size"] for m in self.sensor_modes}
        sizes |= {(4056,3040),(3840,2160),(2028,1520),(2028,1080),(1920,1080),(1280,720),(640,480)}
        sw,sh=self._sensor_max()
        sizes={s for s in sizes if s[0]<=sw and s[1]<=sh}
        return sorted(list(sizes))

    # ---------- configure ----------
    def _apply_config(self):
        W,H=self.s["resolution"]; bd=12
        maxfps=self._max_fps_for((W,H))
        self.s["fps"]=min(self.s["fps"], maxfps)
        fd=int(1e6/max(1,self.s["fps"]))
        t=Transform(hflip=self.s["hflip"], vflip=self.s["vflip"], rotation=self.s["rot"])
        # ÐšÐ»ÑŽÑ‡ÐµÐ²Ð¾Ð¹ Ð¼Ð¾Ð¼ÐµÐ½Ñ‚: main=YUV420 (Ð´Ð»Ñ ÐºÐ¾Ð´ÐµÐºÐ°), lores=RGB (Ð´Ð»Ñ Ð±Ñ‹ÑÑ‚Ñ€Ð¾Ð³Ð¾ Ð¿Ñ€ÐµÐ²ÑŒÑŽ), display="lores"
        try:
            vd=self.cam.create_video_configuration(
                main={"size":(W,H), "format":"YUV420"},
                lores={"size":(960,540), "format":"XRGB8888"},
                display="lores",
                transform=t,
                controls={"FrameDurationLimits":(fd,fd)},
                sensor={'bit_depth': bd}
            )
        except Exception:
            vd=self.cam.create_video_configuration(
                main={"size":(W,H), "format":"YUV420"},
                lores={"size":(960,540), "format":"XBGR8888"},
                display="lores",
                transform=t,
                controls={"FrameDurationLimits":(fd,fd)},
                sensor={'bit_depth': bd}
            )
        sd=self.cam.create_still_configuration(main={"size":tuple(self.s["photo_size"])}, transform=t, sensor={'bit_depth': bd})
        if self.cam.started:
            try: self.cam.stop()
            except Exception: pass
        self.cam.configure(vd); self.vcfg,self.scfg=vd,sd

    def start_preview(self):
        if not self.cam.started: self.cam.start()
        self.apply_controls()

    # ---------- emulation & controls ----------
    def _apply_emulation(self):
        px=self._px(); name=self.s.get(px+"emu","Fuji / Provia")
        e=EMULATIONS.get(name, EM())
        self.s[px+"ev"]=float(e["ev"])
        self.s[px+"contrast"]=int(e["c"])
        self.s[px+"saturation"]=int(e["s"])
        self.s[px+"sharpness"]=int(e["sh"])
        self.s[px+"ccm"]=e["ccm"]

    def apply_controls(self):
        C=controls; px=self._px()
        self._apply_emulation()
        ctr={"ExposureValue": float(self.s[px+"ev"])}
        wb=self.s[px+"awb"]
        if wb=="kelvin":
            ctr["AwbEnable"]=False; ctr["ColourGains"]=kelvin_to_gains(int(self.s[px+"kelvin"]))
        elif wb=="manual":
            ctr["AwbEnable"]=False; ctr["ColourGains"]=(float(self.s[px+"rg"]), float(self.s[px+"bg"]))
        else:
            ctr["AwbEnable"]=True
            try:
                ctr["AwbMode"]={"daylight":C.AwbModeEnum.Daylight,"cloudy":C.AwbModeEnum.Cloudy,"tungsten":C.AwbModeEnum.Tungsten,"fluorescent":C.AwbModeEnum.Fluorescent}.get(wb,C.AwbModeEnum.Auto)
            except Exception: pass
        if self.s[px+"ae"]:
            ctr["AeEnable"]=True
        else:
            ctr["AeEnable"]=False; ctr["ExposureTime"]=int(self.s[px+"shutter"]); ctr["AnalogueGain"]=float(self.s[px+"gain"])
        b=self.s[px+"bright"]; c=self.s[px+"contrast"]; s=self.s[px+"saturation"]; sh=self.s[px+"sharpness"]; ccm=self.s.get(px+"ccm",CCM_PRESETS["Identity"])
        ccm_bias=AWB_AUTO_BIAS.get(self.s.get(px+'awb_bias','Std'), CCM_PRESETS["Identity"]) if wb=="auto" else CCM_PRESETS["Identity"]
        if self._lab_bypass: b,c,s,sh=0,100,100,100; ccm=CCM_PRESETS["Identity"]; ccm_bias=CCM_PRESETS["Identity"]
        ctr.update({"Brightness":clamp11(b),"Contrast":clamp01(c),"Saturation":clamp01(s),"Sharpness":clamp01(sh)})
        try:
            cm=[ccm[i]+ccm_bias[i]-1 if i in (0,4,8) else ccm[i]+ccm_bias[i] for i in range(9)]
            ctr["ColourCorrectionMatrix"]=list(map(float,cm))
        except Exception: pass
        if ctr != self._last_applied_controls:
            try: self.cam.set_controls(ctr); self._last_applied_controls=ctr
            except Exception as e: self._status(f"Controls err: {e}")

    # ---------- MENU ----------
    def _reset_all_visuals(self):
        # Ð¡Ð±Ñ€Ð¾Ñ Ð¢ÐžÐ›Ð¬ÐšÐž Ð²Ð¸Ð·ÑƒÐ°Ð»Ð° (Ð¸ Ð´Ð»Ñ Ñ‚ÐµÐºÑƒÑ‰ÐµÐ³Ð¾ Ñ€ÐµÐ¶Ð¸Ð¼Ð°)
        px=self._px()
        self.s[px+"bright"]=0; self.s[px+"contrast"]=100; self.s[px+"saturation"]=100; self.s[px+"sharpness"]=100
        self.s[px+"ccm_name"]="Identity"; self.s[px+"ccm"]=CCM_PRESETS["Identity"]
        self.s[px+"emu"]="Fuji / Provia"
        self.s[px+"awb_bias"]="Std"
        self.s[px+"kelvin"]=5600; self.s[px+"rg"]=1.5; self.s[px+"bg"]=1.2
        self.apply_controls(); self._refresh_labels(); self._save_settings()

    def open_full_menu(self):
        dlg=QDialog(self); dlg.setWindowTitle("Settings")
        tabs=QTabWidget(dlg)

        sysw=QWidget(); fs=QFormLayout(sysw)
        self.lbl_vroot=QLabel(self.s["vroot"]); b_v=QPushButton("Changeâ€¦"); b_v.clicked.connect(lambda:self._pick_dir("vroot"))
        self.lbl_pdir=QLabel(self.s["pdir"]);  b_p=QPushButton("Changeâ€¦"); b_p.clicked.connect(lambda:self._pick_dir("pdir"))
        r2=QHBoxLayout(); r2.addWidget(self.lbl_vroot,1); r2.addWidget(b_v)
        r1=QHBoxLayout(); r1.addWidget(self.lbl_pdir,1);  r1.addWidget(b_p)
        self.cmb_codec=QComboBox(); self.cmb_codec.addItems(["H264","MJPEG"]); self.cmb_codec.setCurrentText(self.s["encoder"])
        self.spn_br=QDoubleSpinBox(); self.spn_br.setRange(2.0, 200.0); self.spn_br.setDecimals(1); self.spn_br.setValue(self.s["bitrate_mbps"])
        btn_exit=QPushButton("Exit to OS"); btn_exit.clicked.connect(lambda:QCoreApplication.quit())
        fs.addRow("Videos root", QWidget()); fs.addRow(r2); fs.addRow("Photos root", QWidget()); fs.addRow(r1)
        fs.addRow("Encoder", self.cmb_codec); fs.addRow("Bitrate (Mbps)", self.spn_br); fs.addRow(btn_exit)
        tabs.addTab(sysw,"System")

        phw=QWidget(); fph=QFormLayout(phw)
        self.cmb_photo_fmt=QComboBox(); self.cmb_photo_fmt.addItems(["JPEG","RAW+JPEG" if self._DNGWriter else "RAW N/A"]); self.cmb_photo_fmt.setCurrentText("RAW+JPEG" if self.s["photo_raw"] and self._DNGWriter else "JPEG")
        fph.addRow("Photo format", self.cmb_photo_fmt)
        tabs.addTab(phw,"Photo")

        emw=QWidget(); fem=QVBoxLayout(emw)
        self.list_emu=QListWidget()
        for name in sorted(EMULATIONS.keys()): QListWidgetItem(name,self.list_emu)
        cur=self.s[self._px()+"emu"]
        for i in range(self.list_emu.count()):
            if self.list_emu.item(i).text()==cur: self.list_emu.setCurrentRow(i); break
        fem.addWidget(self.list_emu)
        btn_apply_emu=QPushButton("Apply"); btn_apply_emu.clicked.connect(self._apply_emu_from_menu)
        fem.addWidget(btn_apply_emu)
        tabs.addTab(emw,"Emulations")

        w2=QTabWidget()
        btab=QWidget(); fb=QFormLayout(btab)
        self.sld_b=QSlider(Qt.Horizontal); self.sld_b.setRange(-100,100); self.sld_b.setValue(self.s[self._px()+"bright"])
        self.sld_c=QSlider(Qt.Horizontal); self.sld_c.setRange(0,200); self.sld_c.setValue(self.s[self._px()+"contrast"])
        self.sld_s=QSlider(Qt.Horizontal); self.sld_s.setRange(0,200); self.sld_s.setValue(self.s[self._px()+"saturation"])
        self.sld_sh=QSlider(Qt.Horizontal); self.sld_sh.setRange(0,200); self.sld_sh.setValue(self.s[self._px()+"sharpness"])
        fb.addRow("Brightness", self.sld_b); fb.addRow("Contrast", self.sld_c); fb.addRow("Saturation", self.sld_s); fb.addRow("Sharpness", self.sld_sh)
        w2.addTab(btab,"Basic")

        wbt=QWidget(); ft=QFormLayout(wbt)
        self.sld_kelvin=QSlider(Qt.Horizontal); self.sld_kelvin.setRange(2500,8000); self.sld_kelvin.setValue(int(self.s.get(self._px()+"kelvin",5600)))
        self.sld_rg=QSlider(Qt.Horizontal); self.sld_rg.setRange(50,300); self.sld_rg.setValue(int(self.s.get(self._px()+"rg",1.5)*100))
        self.sld_bg=QSlider(Qt.Horizontal); self.sld_bg.setRange(50,300); self.sld_bg.setValue(int(self.s.get(self._px()+"bg",1.2)*100))
        ft.addRow("Kelvin", self.sld_kelvin); ft.addRow("WB R gain", self.sld_rg); ft.addRow("WB B gain", self.sld_bg)
        w2.addTab(wbt,"WB & Tint")

        adv=QWidget(); fa=QFormLayout(adv)
        self.cmb_ccm=QComboBox(); self.cmb_ccm.addItems(list(CCM_PRESETS.keys())); self.cmb_ccm.setCurrentText(self.s.get(self._px()+"ccm_name","Identity"))
        self.btn_lab_reset=QPushButton("Reset LAB"); self.btn_lab_reset.clicked.connect(self._lab_reset)
        self.btn_reset_all=QPushButton("Reset ALL visuals"); self.btn_reset_all.clicked.connect(self._reset_all_visuals)
        self.btn_lab_preview=QPushButton("Preview A/B"); self.btn_lab_preview.setCheckable(True); self.btn_lab_preview.setChecked(False); self.btn_lab_preview.toggled.connect(self._lab_toggle_preview)
        self.sld_opacity=QSlider(Qt.Horizontal); self.sld_opacity.setRange(40,100); self.sld_opacity.setValue(100)
        self.btn_lab_snap=QPushButton("Update preview")
        self.lbl_lab_preview=QLabel(); self.lbl_lab_preview.setFixedHeight(120); self.lbl_lab_preview.setAlignment(Qt.AlignCenter)
        fa.addRow("CCM preset", self.cmb_ccm)
        fa.addRow(self.btn_lab_reset, self.btn_lab_preview)
        fa.addRow(self.btn_reset_all)
        fa.addRow("Panel Opacity", self.sld_opacity)
        fa.addRow(self.btn_lab_snap, self.lbl_lab_preview)
        w2.addTab(adv,"Matrix")

        for sld in [self.sld_b,self.sld_c,self.sld_s,self.sld_sh,self.sld_kelvin,self.sld_rg,self.sld_bg]:
            sld.valueChanged.connect(self._lab_live_apply)
        self.cmb_ccm.currentTextChanged.connect(self._lab_live_apply)
        self.btn_lab_snap.clicked.connect(self._lab_make_preview)

        tabs.addTab(w2,"Colour Studio")

        lutw=QWidget(); fl=QVBoxLayout(lutw)
        self.lbl_lut_dir=QLabel(f"LUTs dir: {LUT_DIR}")
        self.list_luts=QListWidget(); self._reload_luts_list()
        fl.addWidget(self.lbl_lut_dir); fl.addWidget(self.list_luts)
        row=QHBoxLayout()
        btn_reload=QPushButton("Reload"); btn_reload.clicked.connect(self._reload_luts_list); row.addWidget(btn_reload)
        btn_pick=QPushButton("Addâ€¦"); btn_pick.clicked.connect(self._pick_lut_file); row.addWidget(btn_pick)
        btn_clear=QPushButton("Clear"); btn_clear.clicked.connect(self._clear_lut); row.addWidget(btn_clear)
        fl.addLayout(row)
        tabs.addTab(lutw,"LUTs (post)")

        ok=QPushButton("OK"); cancel=QPushButton("Cancel")
        ok.clicked.connect(lambda:self._apply_full_menu(dlg)); cancel.clicked.connect(dlg.reject)
        row=QHBoxLayout(); row.addStretch(1); row.addWidget(ok); row.addWidget(cancel)
        box=QVBoxLayout(dlg); box.addWidget(tabs); box.addLayout(row)
        geo=QGuiApplication.primaryScreen().availableGeometry(); dlg.resize(min(760,geo.width()-40), min(660,geo.height()-60))
        self.sld_opacity.valueChanged.connect(lambda v: dlg.setWindowOpacity(v/100.0))
        dlg.exec_()

    def _apply_emu_from_menu(self):
        it=self.list_emu.currentItem()
        if not it: return
        name=it.text(); px=self._px()
        self.s[px+"emu"]=name
        self.apply_controls(); self._refresh_labels(); self._save_settings()

    def _reload_luts_list(self):
        self.list_luts.clear()
        files=[f for f in os.listdir(LUT_DIR) if f.lower().endswith((".cube",".3dl"))]
        for f in sorted(files): QListWidgetItem(f,self.list_luts)
        if self.s.get("post_lut"):
            cur=os.path.basename(self.s["post_lut"])
            for i in range(self.list_luts.count()):
                if self.list_luts.item(i).text()==cur: self.list_luts.setCurrentRow(i); break
    def _pick_lut_file(self):
        path,_=QFileDialog.getOpenFileName(self,"Select LUT", os.path.expanduser("~"), "LUT files (*.cube *.3dl)")
        if path:
            try:
                base=os.path.basename(path); dst=os.path.join(LUT_DIR, base)
                if os.path.abspath(path)!=os.path.abspath(dst):
                    with open(path,"rb") as src, open(dst,"wb") as dstf: dstf.write(src.read())
                self.s["post_lut"]=dst; self._save_settings(); self._reload_luts_list(); self._status(f"LUT: {base}")
            except Exception as e:
                self._status(f"LUT copy err: {e}")
    def _clear_lut(self):
        self.s["post_lut"]=""; self._save_settings(); self._reload_luts_list(); self._status("LUT cleared")

    def _lab_make_preview(self):
        try:
            arr=self.cam.capture_array("lores")  # Ð±Ñ‹ÑÑ‚Ñ€Ð¾
            h,w,_=arr.shape
            img=QImage(arr.data, w, h, 3*w, QImage.Format_RGB888)
            pix=QPixmap.fromImage(img.rgbSwapped()).scaledToHeight(120, Qt.SmoothTransformation)
            self.lbl_lab_preview.setPixmap(pix)
        except Exception as e:
            self.lbl_lab_preview.setText(f"preview err: {e}")
    def _lab_reset(self):
        px=self._px()
        self.s[px+"bright"]=0; self.s[px+"contrast"]=100; self.s[px+"saturation"]=100; self.s[px+"sharpness"]=100
        self.s[px+"ccm_name"]="Identity"; self.s[px+"ccm"]=CCM_PRESETS["Identity"]
        self.apply_controls(); self._refresh_labels(); self._save_settings()
        for attr,val in (("sld_b",0),("sld_c",100),("sld_s",100),("sld_sh",100)):
            if hasattr(self,attr):
                sld=getattr(self,attr); sld.blockSignals(True); sld.setValue(val); sld.blockSignals(False)
        if hasattr(self,"cmb_ccm"):
            self.cmb_ccm.blockSignals(True); self.cmb_ccm.setCurrentText("Identity"); self.cmb_ccm.blockSignals(False)
    def _lab_toggle_preview(self,on):
        self._lab_bypass=on; self.apply_controls()
    def _lab_live_apply(self):
        px=self._px()
        if hasattr(self,"sld_b"): self.s[px+"bright"]=int(self.sld_b.value())
        if hasattr(self,"sld_c"): self.s[px+"contrast"]=int(self.sld_c.value())
        if hasattr(self,"sld_s"): self.s[px+"saturation"]=int(self.sld_s.value())
        if hasattr(self,"sld_sh"): self.s[px+"sharpness"]=int(self.sld_sh.value())
        if hasattr(self,"cmb_ccm"): self.s[px+"ccm_name"]=self.cmb_ccm.currentText(); self.s[px+"ccm"]=CCM_PRESETS[self.s[px+"ccm_name"]]
        if hasattr(self,"sld_kelvin"): self.s[px+"kelvin"]=int(self.sld_kelvin.value())
        if hasattr(self,"sld_rg"): self.s[px+"rg"]=max(0.5,min(3.0,self.sld_rg.value()/100.0))
        if hasattr(self,"sld_bg"): self.s[px+"bg"]=max(0.5,min(3.0,self.sld_bg.value()/100.0))
        self.apply_controls()

    def _pick_dir(self,key):
        d=QFileDialog.getExistingDirectory(self,"Choose folder", self.s[key])
        if d:
            self.s[key]=d
            if key=="vroot" and hasattr(self,'lbl_vroot'): self.lbl_vroot.setText(d)
            if key=="pdir"  and hasattr(self,'lbl_pdir'):  self.lbl_pdir.setText(d)

    def _apply_full_menu(self, dlg):
        if self.recording or self._photo_busy: self._status("Busyâ€¦"); dlg.reject(); return
        self.s["encoder"]=self.cmb_codec.currentText()
        self.s["bitrate_mbps"]=float(self.spn_br.value())
        self.s["photo_raw"]= (self.cmb_photo_fmt.currentText()=="RAW+JPEG" and self._DNGWriter is not None)
        self._apply_config()
        if not self.cam.started: self.cam.start()
        self.apply_controls(); dlg.accept(); self._refresh_labels(); self._save_settings(); self._status("Settings applied")

    # ---------- Quick UI ----------
    def _refresh_labels(self):
        self.btn_res.setText(self._res_label())
        self.btn_fps.setText(f"FPS {self.s['fps']}")
        self.btn_codec.setText(self.s["encoder"])
        self.btn_iso.setText(self._iso_label())
        self.btn_shtr.setText(self._shutter_label())
        self.btn_ev.setText(self._ev_label())
        self.btn_mode.setText("VID" if self.s["capture_mode"]=="video" else "PIC")
        w,h=self.s['resolution']; self.lbl_status.setText(f"{w}x{h} | {self.s['fps']}fps | {self.s['encoder']} | Emu:{self.s.get(self._px()+'emu')} | LUT:{os.path.basename(self.s['post_lut']) if self.s.get('post_lut') else 'â€”'}")

    def _fps_options_for_current(self):
        maxfps=self._max_fps_for(self.s["resolution"])
        opts=[x for x in self.FPS_BASE if x<=maxfps]
        return opts or [int(maxfps)]

    def ui_pick_res(self):
        items=[f"{w}x{h}" for (w,h) in self._candidate_res()]
        pl=PopupList(self,"Resolution", items, current=f"{self.s['resolution'][0]}x{self.s['resolution'][1]}")
        if pl.exec_() and pl.selected():
            w,h=map(int,pl.selected().split("x"))
            self.s["resolution"]=(w,h)
            self.s["fps"]=min(self.s["fps"], self._max_fps_for((w,h)))
            self._apply_config()
            if not self.cam.started: self.cam.start()
            self.apply_controls(); self._refresh_labels(); self._save_settings()

    def ui_pick_fps(self):
        opts=[str(x) for x in self._fps_options_for_current()]
        pl=PopupList(self,"Framerate",opts, current=str(self.s["fps"]))
        if pl.exec_() and pl.selected():
            self.s["fps"]=int(pl.selected()); self._apply_config()
            if not self.cam.started: self.cam.start()
            self.apply_controls(); self._refresh_labels(); self._save_settings()

    def ui_pick_codec(self):
        pl=PopupList(self,"Codec",["H264","MJPEG"], current=self.s["encoder"])
        if pl.exec_() and pl.selected(): self.s["encoder"]=pl.selected(); self._save_settings(); self._refresh_labels()

    def ui_pick_iso(self):
        isos=[100,200,400,800,1600,3200,6400,12800]
        px=self._px(); cur=int(self.s[px+"gain"]*100)
        pl=PopupList(self,"ISO",[str(x) for x in isos], current=str(min(isos,key=lambda v:abs(v-cur))))
        if pl.exec_() and pl.selected():
            self.s[px+"ae"]=False; iso=int(pl.selected()); self.s[px+"gain"]=min(32.0,max(1.0,iso/100.0))
            self.apply_controls(); self._refresh_labels(); self._save_settings()

    def ui_pick_shutter(self):
        px=self._px()
        if self.s["capture_mode"]=="video":
            angles=[45,90,144,180,216,270]
            try: cur=int(self.btn_shtr.text().replace("Â°","").strip())
            except Exception: cur=180
            pl=PopupList(self,"Shutter Angle",[str(a) for a in angles], current=str(cur))
            if pl.exec_() and pl.selected():
                a=int(pl.selected()); t_us=int(round(1_000_000.0*(a/360.0)/self.s["fps"]))
                self.s[px+"ae"]=False; self.s[px+"shutter"]=t_us
                self.apply_controls(); self._refresh_labels(); self._save_settings()
        else:
            ps=PopupSlider(self,"Shutter (Âµs)", 50, 1000000, 10, self.s[px+"shutter"], decimals=0, unit="Âµs", fmt="{:.0f}")
            if ps.exec_():
                self.s[px+"ae"]=False; self.s[px+"shutter"]=int(ps.value); self.apply_controls(); self._refresh_labels(); self._save_settings()

    def ui_pick_ev(self):
        px=self._px()
        ps=PopupSlider(self,"Exposure Compensation",-4.0,4.0,0.1,self.s[px+"ev"],decimals=1,fmt="{:+.1f}")
        if ps.exec_():
            self.s[px+"ev"]=round(float(ps.value),1); self.apply_controls(); self._refresh_labels(); self._save_settings()

    def open_wb_popup(self):
        WBDialog(self).exec_()

    def ui_pick_transform(self):
        if self.recording: self._status("Stop REC to change transform"); return
        pl=PopupList(self,"Transform",["Toggle HFlip","Toggle VFlip","Rotate 90","Rotate 180","Rotate 270"])
        if pl.exec_() and pl.selected():
            sel=pl.selected()
            if sel=="Toggle HFlip": self.s["hflip"]=not self.s["hflip"]
            elif sel=="Toggle VFlip": self.s["vflip"]=not self.s["vflip"]
            elif sel=="Rotate 90": self.s["rot"]=(self.s["rot"]+90)%360
            elif sel=="Rotate 180": self.s["rot"]=(self.s["rot"]+180)%360
            elif sel=="Rotate 270": self.s["rot"]=(self.s["rot"]+270)%360
            self._apply_config()
            if not self.cam.started: self.cam.start()
            self.apply_controls(); self._save_settings()

    # ---------- Photo ----------
    def _update_hud(self):
        photo=(self.s["capture_mode"]=="photo")
        if photo:
            self.btn_rec.hide(); self.btn_photo_res.show(); self.btn_shot.setText("ðŸ“· Shoot")
        else:
            self.btn_rec.show(); self.btn_photo_res.hide(); self.btn_shot.setText("ðŸ“· Shot")

    def ui_pick_photo_res(self):
        items=[f"{w}x{h}" for (w,h) in self._candidate_res()]
        cur=f"{self.s['photo_size'][0]}x{self.s['photo_size'][1]}"
        pl=PopupList(self,"Photo Resolution", items, current=cur)
        if pl.exec_() and pl.selected():
            w,h=map(int, pl.selected().split("x"))
            self.s["photo_size"]=(w,h); self._save_settings(); self._status(f"Photo size {w}x{h}")

    def open_presets(self):
        PresetsDialog(self).exec_()

    def open_gallery(self):
        QDesktopServices.openUrl(QUrl.fromLocalFile(self.s["vroot"]))

    def _make_preset_state(self): return dict(self.s)

    def _apply_preset_state(self,st):
        if self.recording: self._status("Stop REC to load preset"); return
        self.s.update(st); self._apply_config()
        if not self.cam.started: self.cam.start()
        self.apply_controls(); self._refresh_labels(); self._save_settings()

    def toggle_capture_mode(self):
        if self.recording or self._photo_busy: self._status("Busyâ€¦"); return
        self.s["capture_mode"]= "video" if self.s["capture_mode"]=="photo" else "photo"
        self._update_hud(); self.apply_controls(); self._refresh_labels(); self._save_settings()

    def _flash_tick(self): self.flash.setVisible(False)

    def take_photo(self):
        if self._photo_busy or self.recording: self._status("Busyâ€¦"); return
        self._photo_busy=True; self._status("Saving photoâ€¦")
        g=self.preview.geometry()
        self.flash.setGeometry(QRect(self.preview.x(), self.preview.y(), g.width(), g.height()))
        self.flash.raise_(); self.flash.setVisible(True); QTimer.singleShot(120, self._flash_tick)
        def _shot():
            err=None
            try:
                W,H=self.s["photo_size"]; t=Transform(hflip=self.s["hflip"], vflip=self.s["vflip"], rotation=self.s["rot"])
                sd=self.cam.create_still_configuration(main={"size":(W,H)}, transform=t)
                outdir=os.path.join(self.s["vroot"],"Photos", datetime.now().strftime("%Y-%m-%d")); os.makedirs(outdir,exist_ok=True)
                fn_jpg=os.path.join(outdir, f"IMG_{ts()}.jpg")
                self.cam.switch_mode_and_capture_file(sd, fn_jpg)
                if self.s["photo_raw"] and self._DNGWriter is not None:
                    try:
                        dng_fn=os.path.join(outdir, f"IMG_{ts()}.dng")
                        dng=self._DNGWriter(self.cam); dng.save(dng_fn)
                    except Exception as e:
                        err=f"DNG: {e}"
                if self.cam.started: self.cam.stop()
                self.cam.configure(self.vcfg); self.cam.start()
            except Exception as e:
                err=e
            self._photo_busy=False; self._status("Photo saved" + (f" (err: {err})" if err else ""))
        threading.Thread(target=_shot, daemon=True).start()

    # ---------- Video ----------
    def toggle_rec(self,on): self.start_rec() if on else self.stop_rec()

    def start_rec(self):
        if self.recording or self._photo_busy: return
        try:
            from picamera2.encoders import H264Encoder, MJPEGEncoder
            try:
                from picamera2.outputs import FfmpegOutput, FileOutput
            except Exception:
                from picamera2.outputs import FileOutput; FfmpegOutput=None

            W,H=self.s["resolution"]
            base=1920*1080*30; cur=W*H*self.s["fps"]
            if "bitrate_mbps" not in self.s or self.s["bitrate_mbps"]<=0:
                self.s["bitrate_mbps"]=max(6.0, min(200.0, 12.0*(cur/base)))
            br=int(self.s["bitrate_mbps"]*1_000_000)

            outdir=os.path.join(self.s["vroot"], datetime.now().strftime("%Y-%m-%d")); os.makedirs(outdir,exist_ok=True)
            basefn=f"VID_{ts()}_{W}x{H}@{self.s['fps']}"

            if self.s["encoder"]=="MJPEG":
                encoder=MJPEGEncoder()
                if 'FfmpegOutput' in locals() and FfmpegOutput is not None:
                    path=os.path.join(outdir, basefn+".avi"); output=FfmpegOutput(path)
                else:
                    path=os.path.join(outdir, basefn+".mjpeg"); output=FileOutput(path)
            else:
                encoder=H264Encoder(bitrate=br)
                if 'FfmpegOutput' in locals() and FfmpegOutput is not None:
                    path=os.path.join(outdir, basefn+".mp4"); output=FfmpegOutput(path)
                else:
                    path=os.path.join(outdir, basefn+".h264"); output=FileOutput(path)

            if not self.cam.started: self.cam.start()
            self.cam.start_recording(encoder, output)
            self._last_record_path=path
            self.recording=True; self.rec_started_at=time.time()
            self.lbl_rec.setVisible(True); self.lbl_rectime.setVisible(True); self.btn_rec.setText("â–  STOP")
            if not self.tmr.isActive(): self.tmr.start()
            self._status(f"REC {W}x{H}@{self.s['fps']} {self.s['encoder']} â†’ {os.path.basename(path)}")
        except Exception as e:
            self.btn_rec.setChecked(False); self._status(f"REC err: {e}")

    def stop_rec(self):
        if not self.recording or self._stop_pending: return
        self._stop_pending=True; self._stop_done=False; self._stop_err=None; self.btn_rec.setText("â€¦")
        def _stop():
            try: self.cam.stop_recording()
            except Exception as e: self._stop_err=e
            finally: self._stop_done=True
        threading.Thread(target=_stop, daemon=True).start()

    def _postprocess_lut(self, src_path, lut_path):
        try:
            import subprocess
            dst=src_path.rsplit(".",1)[0]+"_lut.mp4"
            cmd=['ffmpeg','-y','-hide_banner','-loglevel','error','-i',src_path,'-vf',f'lut3d={lut_path}','-c:v','libx264','-preset','veryfast','-crf','18','-c:a','copy',dst]
            subprocess.run(cmd, check=True)
            self._status(f"LUT applied â†’ {os.path.basename(dst)}")
        except Exception as e:
            self._status(f"LUT err: {e}")

    # ---------- tick / status ----------
    def _tick(self):
        if self.recording and self.rec_started_at is not None and not self._stop_pending:
            el=int(time.time()-self.rec_started_at); mm,ss=divmod(el,60); self.lbl_rectime.setText(f"{mm:02d}:{ss:02d}")
        if self._stop_pending and self._stop_done:
            self.recording=False; self.rec_started_at=None
            self.lbl_rec.setVisible(False); self.lbl_rectime.setVisible(False); self.btn_rec.setText("â— REC"); self.btn_rec.setChecked(False)
            if self.tmr.isActive(): self.tmr.stop()
            self._status("REC stopped" + (f" (err: {self._stop_err})" if self._stop_err else "")); self._stop_pending=False; self._stop_done=False; self._stop_err=None
            if self._last_record_path and self.s.get("post_lut"):
                path=self._last_record_path; lut=self.s["post_lut"]
                threading.Thread(target=self._postprocess_lut, args=(path,lut), daemon=True).start()

    def _status(self,txt): self.lbl_status.setText(txt)

    # ---------- Splash ----------
    def _show_splash(self):
        splash=QDialog(self); splash.setModal(False); splash.setWindowFlags(Qt.FramelessWindowHint|Qt.Dialog)
        lay=QVBoxLayout(splash)
        t1=QLabel("MEDVEKAM"); t1.setAlignment(Qt.AlignCenter); t1.setStyleSheet("color:#ff9a2e;"); t1.setFont(QFont("Arial", 28, QFont.Bold))
        t2=QLabel("by Misek Ejl"); t2.setAlignment(Qt.AlignCenter); t2.setStyleSheet("color:#cccccc;"); t2.setFont(QFont("Arial", 14))
        lay.addWidget(t1); lay.addWidget(t2)
        splash.resize(420,160)
        g=self.geometry(); splash.move(self.x()+(800-420)//2, self.y()+(640-160)//2)
        splash.show(); QTimer.singleShot(1500, splash.close)

    def closeEvent(self,e):
        try:
            if self.recording: self.cam.stop_recording()
        except Exception: pass
        try:
            if self.cam.started: self.cam.stop()
        except Exception: pass
        self._save_settings(); e.accept()

# ---------- Presets dialog ----------
class PresetsDialog(QDialog):
    def __init__(self,parent):
        super().__init__(parent); self.setWindowTitle("Presets (10 slots)"); self.setModal(True)
        self.parent=parent
        lay=QVBoxLayout(self); self.rows=[]; self.data=self._load()
        for idx in range(10):
            row=QHBoxLayout(); name=self.data.get(str(idx),{}).get("name",f"Slot {idx+1}")
            lbl=QLabel(name); lbl.setStyleSheet("font-size:16px;")
            bL=QPushButton("Load"); bS=QPushButton("Save"); bR=QPushButton("Rename"); bC=QPushButton("Clear")
            row.addWidget(lbl,1); row.addWidget(bL); row.addWidget(bS); row.addWidget(bR); row.addWidget(bC); lay.addLayout(row)
            self.rows.append((lbl,bL,bS,bR,bC))
        close=QPushButton("Close"); close.clicked.connect(self.accept); lay.addWidget(close)
        for i,(lbl,bL,bS,bR,bC) in enumerate(self.rows):
            bL.clicked.connect(lambda _,k=i:self._load_slot(k))
            bS.clicked.connect(lambda _,k=i:self._save_slot(k))
            bR.clicked.connect(lambda _,k=i:self._rename_slot(k))
            bC.clicked.connect(lambda _,k=i:self._clear_slot(k))
        self.resize(640,520)
    def _load(self):
        try:
            with open(PRESETS_FILE,"r",encoding="utf-8") as f: return json.load(f)
        except Exception: return {}
    def _save_all(self):
        with open(PRESETS_FILE,"w",encoding="utf-8") as f: json.dump(self.data, f, ensure_ascii=False, indent=2)
    def _rename_slot(self,i):
        name, ok = QInputDialog.getText(self,"Rename preset","Name:", text=self.data.get(str(i),{}).get("name",f"Slot {i+1}"))
        if ok:
            slot=self.data.get(str(i),{}); slot["name"]=name.strip() or f"Slot {i+1}"
            self.data[str(i)]=slot; self._save_all(); self.rows[i][0].setText(slot["name"])
    def _save_slot(self,i):
        st=self.parent._make_preset_state()
        slot={"name": self.data.get(str(i),{}).get("name",f"Slot {i+1}"), "state": st}
        self.data[str(i)]=slot; self._save_all(); self.parent._status(f"Preset saved â†’ {slot['name']}")
    def _load_slot(self,i):
        slot=self.data.get(str(i))
        if not slot or "state" not in slot: self.parent._status("Empty slot"); return
        self.parent._apply_preset_state(slot["state"]); self.parent._status(f"Preset loaded â† {slot['name']}")
    def _clear_slot(self,i):
        if str(i) in self.data: del self.data[str(i)]
        self._save_all(); self.rows[i][0].setText(f"Slot {i+1}"); self.parent._status("Preset cleared")

def main():
    QCoreApplication.setAttribute(Qt.AA_SynthesizeTouchForUnhandledMouseEvents, True)
    QCoreApplication.setAttribute(Qt.AA_SynthesizeMouseForUnhandledTouchEvents, True)
    os.environ.setdefault("QT_SCALE_FACTOR","1.0")
    app=QApplication(sys.argv); w=App(); w.resize(800,640); w.showFullScreen(); sys.exit(app.exec_())

if __name__=="__main__": main()
PY

cat > "$APP/run.sh" <<'RS'
#!/usr/bin/env bash
export QT_QPA_PLATFORM=xcb
export QT_OPENGL=software
export LIBGL_ALWAYS_SOFTWARE=1
exec /usr/bin/python3 -u "$(dirname "$0")/medvecam_ultra.py"
RS
chmod +x "$APP/run.sh"

DESK="$HOME/Desktop/MedVeCam Ultra.desktop"
cat > "$DESK" <<EOF
[Desktop Entry]
Type=Application
Name=MedVeCam Ultra
Exec=$APP/run.sh
Icon=camera
Terminal=false
EOF
chmod +x "$DESK"

echo "Launchingâ€¦"
"$APP/run.sh"
SH

bash ~/install_medvecam_ultra.sh
